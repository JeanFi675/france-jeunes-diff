---
if (import.meta.env.PROD) {
  return Astro.redirect('/');
}
---

<!doctype html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>√âditeur de Blog Local</title>
    <style>
      body {
        margin: 0;
        font-family:
          -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        display: flex;
        height: 100vh;
        overflow: hidden;
      }
      #sidebar {
        width: 250px;
        background: #f4f4f5;
        border-right: 1px solid #e4e4e7;
        display: flex;
        flex-direction: column;
      }
      #sidebar h2 {
        padding: 1rem;
        margin: 0;
        font-size: 1.2rem;
        border-bottom: 1px solid #e4e4e7;
      }
      #file-list {
        list-style: none;
        padding: 0;
        margin: 0;
        overflow-y: auto;
        flex: 1;
      }
      #file-list li {
        padding: 0.75rem 1rem;
        cursor: pointer;
        border-bottom: 1px solid #eee;
        font-size: 0.9rem;
      }
      #file-list li:hover {
        background: #e4e4e7;
      }
      #file-list li.active {
        background: #e0e7ff;
        color: #3730a3;
        font-weight: 500;
      }

      #main {
        flex: 1;
        display: flex;
        flex-direction: column;
        height: 100%;
      }
      #toolbar {
        padding: 0.75rem 1rem;
        border-bottom: 1px solid #e4e4e7;
        background: #fff;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      #current-file {
        font-weight: bold;
      }
      #save-btn {
        background: #2563eb;
        color: white;
        border: none;
        padding: 0.5rem 1rem;
        border-radius: 0.25rem;
        cursor: pointer;
        font-weight: 500;
      }
      #save-btn:hover {
        background: #1d4ed8;
      }
      #save-btn:disabled {
        background: #93c5fd;
        cursor: not-allowed;
      }

      #editor-container {
        flex: 1;
        display: flex;
        overflow: hidden;
      }
      #editor {
        flex: 1;
        border: none;
        padding: 1rem;
        font-family: 'Consolas', 'Monaco', monospace;
        font-size: 14px;
        resize: none;
        outline: none;
        border-right: 1px solid #e4e4e7;
        line-height: 1.5;
        background: #fafafa;
      }
      #preview {
        flex: 1;
        padding: 1rem 2rem;
        overflow-y: auto;
        background: #fff;
      }

      /* Markdown Preview Styles - REMOVED as we use iframe now */
    </style>
    <!-- Js-yaml for frontmatter parsing -->
    <!-- Custom styles if needed -->
  </head>
  <body>
    <div id="sidebar">
      <h2>Articles</h2>
      <ul id="file-list">
        <!-- Files loaded here -->
      </ul>
    </div>
    <div id="main">
      <div id="toolbar">
        <span id="current-file">S√©lectionnez un fichier...</span>
        <div>
          <button
            id="export-btn"
            style="background: #4b5563; color: white; border: none; padding: 0.5rem 1rem; border-radius: 0.25rem; cursor: pointer; font-weight: 500; margin-right: 0.5rem;"
            disabled>üñ®Ô∏è Export PDF</button
          >
          <button id="save-btn" disabled>Sauvegarder (Ctrl+S)</button>
        </div>
      </div>
      <div id="editor-container">
        <textarea id="editor" placeholder="Le contenu appara√Ætra ici..."></textarea>
        <iframe id="preview" src="/admin/preview" title="Preview"></iframe>
      </div>
    </div>

    <script type="module" is:inline>
      const fileListEl = document.getElementById('file-list');
      const editorEl = document.getElementById('editor');
      const previewIframe = document.getElementById('preview');
      const currentFileEl = document.getElementById('current-file');
      const saveBtn = document.getElementById('save-btn');
      const exportBtn = document.getElementById('export-btn');

      let activeFile = null;
      let isPreviewReady = false;

      // Handle message from preview
      window.addEventListener('message', (e) => {
        if (e.data.type === 'preview-ready') {
          isPreviewReady = true;
          updatePreview(); // Send initial content if ready
        }
      });

      // Fetch file list
      async function loadFileList() {
        try {
          const res = await fetch('/api/local/posts.json');
          const data = await res.json();
          renderFileList(data.files || []);
        } catch (err) {
          // eslint-disable-next-line no-console
          console.error('Failed to load posts', err);
        }
      }

      function renderFileList(files) {
        fileListEl.innerHTML = '';
        files.forEach((file) => {
          const li = document.createElement('li');
          li.textContent = file;
          li.onclick = () => loadFile(file);
          if (activeFile === file) li.classList.add('active');
          fileListEl.appendChild(li);
        });
      }

      async function loadFile(filename) {
        // eslint-disable-next-line no-console
        console.log('loadFile called with:', filename);
        if (!filename) {
          // eslint-disable-next-line no-console
          console.error('loadFile called with null/empty filename');
          return;
        }
        activeFile = filename;
        currentFileEl.textContent = filename;
        saveBtn.disabled = true; // Disable save during load
        exportBtn.disabled = true;
        editorEl.value = 'Chargement...'; // Show loading state
        editorEl.disabled = true;

        // Update active state in list
        Array.from(fileListEl.children).forEach((li) => {
          if (li.textContent === filename) li.classList.add('active');
          else li.classList.remove('active');
        });

        const url = `/api/local/post.json?file=${encodeURIComponent(filename)}`;
        try {
          const res = await fetch(url);
          const data = await res.json();

          if (!res.ok || data.error) {
            throw new Error(
              data.error ? `${data.error} (URL: ${data.url || url})` : `Erreur HTTP: ${res.status}`
            );
          }

          editorEl.value = data.content;
          editorEl.disabled = false;
          saveBtn.disabled = false;
          exportBtn.disabled = false;
          updatePreview();
          updatePreview();
        } catch (err) {
          // eslint-disable-next-line no-console
          console.error('Failed to load file content', err);
          editorEl.value = `ERREUR: Impossible de charger le fichier.\nD√©tails: ${err.message}\nURL demand√©e: ${url}`;
          editorEl.disabled = true;
        }
      }

      async function saveFile() {
        if (!activeFile) return;

        const content = editorEl.value;
        saveBtn.textContent = 'Sauvegarde...';

        try {
          const res = await fetch('/api/local/post.json', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ file: activeFile, content }),
          });

          if (res.ok) {
            saveBtn.textContent = 'Sauvegard√© !';
            setTimeout(() => (saveBtn.textContent = 'Sauvegarder (Ctrl+S)'), 2000);
          } else {
            saveBtn.textContent = 'Erreur !';
          }
        } catch (err) {
          // eslint-disable-next-line no-console
          console.error('Failed to save', err);
          saveBtn.textContent = 'Erreur !';
        }
      }

      // ... (existing code) ...

      // --- Social Image Generator ---
      const GOOGLE_FONTS_URL =
        'https://fonts.googleapis.com/css2?family=Inter:wght@900&display=swap';

      // Load Font
      const fontLink = document.createElement('link');
      fontLink.href = GOOGLE_FONTS_URL;
      fontLink.rel = 'stylesheet';
      document.head.appendChild(fontLink);

      async function generateSocialImage(format) {
        if (!activeFile) return;
        const editorText = editorEl.value;
        const { frontmatter } = parseFrontmatter(editorText);

        if (!frontmatter.title) {
          alert('Le titre est manquant dans le frontmatter !');
          return;
        }

        let btn;
        if (format === 'insta') btn = btnInsta;
        else if (format === 'fb') btn = btnFb;
        const originalText = btn.textContent;
        btn.textContent = '‚è≥ G√©n√©ration...';
        btn.disabled = true;

        try {
          // 1. Config dimensions
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');

          let width, height, filenameSuffix;
          if (format === 'insta') {
            width = 1080;
            height = 1080;
            filenameSuffix = 'instagram';
          } else {
            // facebook portrait
            width = 1080;
            height = 1350;
            filenameSuffix = 'facebook-portrait';
          }

          canvas.width = width;
          canvas.height = height;

          // 2. Load Image (Bandeau)
          const bannerUrl = '/images/bandeau-blog-2026.webp';
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.src = bannerUrl;

          await new Promise((resolve, reject) => {
            img.onload = resolve;
            img.onerror = () => reject(new Error('Impossible de charger le bandeau'));
          });

          // 3. Background Logic
          // 3. Background Logic: GRADIENT MESH (Default for all)

          // Extract 2-3 colors (Top Left, Center, Bottom Right)
          const tempCanvas = document.createElement('canvas');
          const tempCtx = tempCanvas.getContext('2d');
          tempCanvas.width = 10;
          tempCanvas.height = 10;
          tempCtx.drawImage(img, 0, 0, 10, 10);
          const data = tempCtx.getImageData(0, 0, 10, 10).data;

          function getRGB(x, y) {
            const i = (y * 10 + x) * 4;
            return `rgb(${data[i]}, ${data[i + 1]}, ${data[i + 2]})`;
          }
          const colorTL = getRGB(2, 2);
          const colorCenter = getRGB(5, 5);
          const colorBR = getRGB(8, 8);

          // Base Fill
          ctx.fillStyle = colorCenter;
          ctx.fillRect(0, 0, width, height);

          // Large Radial Gradients
          // Top Left
          const grad1 = ctx.createRadialGradient(0, 0, 100, 0, 0, width * 0.8);
          grad1.addColorStop(0, colorTL);
          grad1.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = grad1;
          ctx.fillRect(0, 0, width, height);

          // Bottom Right
          const grad2 = ctx.createRadialGradient(width, height, 100, width, height, width * 0.8);
          grad2.addColorStop(0, colorBR);
          grad2.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = grad2;
          ctx.fillRect(0, 0, width, height);

          // Global Gradient Overlay for "Bottom Anchor"
          const bgGradient = ctx.createLinearGradient(0, 0, 0, height);
          bgGradient.addColorStop(0, 'rgba(0,0,0,0)');
          bgGradient.addColorStop(1, 'rgba(0,0,0,0.4)');
          ctx.fillStyle = bgGradient;
          ctx.fillRect(0, 0, width, height);

          // 4. Draw Main Image (Fit/Contain)
          // "Respect des dimensions" -> Contain
          const scaleContain = Math.min(width / img.width, height / img.height);

          const wContain = img.width * scaleContain;
          const hContain = img.height * scaleContain;

          const xContain = (width - wContain) / 2;
          const yContain = (height - hContain) / 2;

          // Draw the image
          ctx.drawImage(img, xContain, yContain, wContain, hContain);

          // 5. Draw Title
          // Replicate CSS positioning relative to the *contained image*
          // CSS: left: 40%; top: 82%; transform: translate(-50%, -50%); width: 80%

          await document.fonts.load('900 100px "Inter"');

          ctx.fillStyle = '#ffffff';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          // Font size matching CSS: 4vw (relative to image width)
          // 4vw of wContain.
          // Note: In browser 4vw is relative to viewport width.
          // If the banner takes full width, it matches.
          // CSS: font-size: clamp(1.8rem, 4vw, 3.2rem);
          // Let's use 4% of the image width, constrained by min/max if needed.
          // For high-res output (wContain ~1080), 4% is ~43px.
          // On a 1920px screen, 4vw is 76px.
          // The banner in the site is max 100% width.
          // Let's aim slightly higher for legibility on static image. 5%?
          // User said "taille du texte comme le bandeau".
          // Let's stick to 4.5% of wContain as a safe bet.
          const fontSize = Math.floor(wContain * 0.045);
          ctx.font = `900 ${fontSize}px "Inter", sans-serif`;

          // Text Shadow per CSS
          // text-shadow: 0 4px 24px rgba(0, 0, 0, 0.6);
          ctx.shadowColor = 'rgba(0, 0, 0, 0.6)';
          ctx.shadowBlur = 24;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 4;

          // Position
          // Center of text block should be at 40% X, 82% Y of the IMAGE.
          const textX = xContain + wContain * 0.4;
          const textY = yContain + hContain * 0.82;
          const maxTextWidth = wContain * 0.8;

          // Text Wrapping
          const words = frontmatter.title.toUpperCase().split(' ');
          let line = '';
          const lines = [];

          for (let n = 0; n < words.length; n++) {
            const testLine = line + words[n] + ' ';
            const metrics = ctx.measureText(testLine);
            const testWidth = metrics.width;
            if (testWidth > maxTextWidth && n > 0) {
              lines.push(line);
              line = words[n] + ' ';
            } else {
              line = testLine;
            }
          }
          lines.push(line);

          // Draw lines
          const lineHeight = fontSize * 1.1;

          lines.forEach((l, i) => {
            const yOffset = (i - (lines.length - 1) / 2) * lineHeight;
            ctx.fillText(l.trim(), textX, textY + yOffset);
          });

          // 6. Download
          const link = document.createElement('a');
          link.download = `${activeFile.replace(/\.md$/, '')}-${filenameSuffix}.png`;
          link.href = canvas.toDataURL('image/png');
          link.click();
        } catch (err) {
          // eslint-disable-next-line no-console
          console.error('Erreur g√©n√©ration image:', err);
          alert("Erreur lors de la g√©n√©ration de l'image : " + err.message);
        } finally {
          btn.textContent = originalText;
          btn.disabled = false;
        }
      }

      // Add buttons logic
      const btnInsta = document.createElement('button');
      btnInsta.textContent = 'üì∏ Insta (Carr√©)';
      btnInsta.style.cssText =
        'background: #E1306C; color: white; border: none; padding: 0.5rem 1rem; border-radius: 0.25rem; cursor: pointer; font-weight: 500; margin-right: 0.5rem;';
      btnInsta.onclick = () => generateSocialImage('insta');

      const btnFb = document.createElement('button');
      btnFb.textContent = 'üì∏ FB (Portrait)';
      btnFb.style.cssText =
        'background: #1877F2; color: white; border: none; padding: 0.5rem 1rem; border-radius: 0.25rem; cursor: pointer; font-weight: 500; margin-right: 0.5rem;';
      btnFb.onclick = () => generateSocialImage('fb');

      // Insert buttons into toolbar before export button
      const toolbarDiv = document.querySelector('#toolbar > div');
      toolbarDiv.insertBefore(btnFb, exportBtn);
      toolbarDiv.insertBefore(btnInsta, btnFb);

      // --- Restored Event Listeners & Helpers ---

      exportBtn.addEventListener('click', () => {
        if (previewIframe.contentWindow) {
          previewIframe.contentWindow.print();
        }
      });

      function updatePreview() {
        if (!isPreviewReady || !previewIframe.contentWindow) return;

        const raw = editorEl.value;
        const { frontmatter, content } = parseFrontmatter(raw);

        previewIframe.contentWindow.postMessage(
          {
            type: 'preview-update',
            frontmatter,
            content,
          },
          '*'
        );
      }

      function parseFrontmatter(text) {
        // Simple manual parsing to avoid external dependencies issues
        const match = text.match(/^---\s*[\r\n]+([\s\S]*?)[\r\n]+---/);
        const frontmatter = {};
        let content = text;

        if (match) {
          const fmText = match[1];
          content = text.slice(match[0].length);

          // Parse Title
          const titleMatch =
            fmText.match(/title:\s*(?:["'])(.*?)(?:["'])/) || fmText.match(/title:\s*([^\n]+)/);
          if (titleMatch) frontmatter.title = titleMatch[1];

          // Parse Description
          const descMatch =
            fmText.match(/description:\s*(?:["'])(.*?)(?:["'])/) ||
            fmText.match(/description:\s*([^\n]+)/);
          if (descMatch) frontmatter.description = descMatch[1];

          // Parse PublishDate
          const dateMatch = fmText.match(/publishDate:\s*([^\n]+)/);
          if (dateMatch) frontmatter.publishDate = dateMatch[1];

          // Parse Tags
          const tagsMatch = fmText.match(/tags:\s*\[(.*?)\]/);
          if (tagsMatch) {
            frontmatter.tags = tagsMatch[1].split(',').map((t) => t.trim().replace(/['"]/g, ''));
          }

          // Parse Flickr
          const flickrMatch =
            fmText.match(/flickrAlbumUrl:\s*(?:["'])(.*?)(?:["'])/) ||
            fmText.match(/flickrAlbumUrl:\s*([^\n]+)/);
          if (flickrMatch) frontmatter.flickrAlbumUrl = flickrMatch[1];

          frontmatter.albumTitle = frontmatter.title;
        }
        return { frontmatter, content };
      }

      // Live preview
      editorEl.addEventListener('input', updatePreview);

      // Save shortcut
      document.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 's') {
          e.preventDefault();
          saveFile();
        }
      });

      saveBtn.addEventListener('click', saveFile);

      // Initial load
      loadFileList();
    </script>
  </body>
</html>
